# gamepad_to_hoverboard_rightstick_speedscale.py
import serial
import time
import pygame

# Parametry
SERIAL_PORT = "/dev/ttyUSB0"   # np. "COM3"
BAUDRATE = 115200
DEADZONE = 0.10                # martwa strefa gaÅ‚ki
SEND_HZ = 30                   # czÄ™stotliwoÅ›Ä‡ wysyÅ‚ania komend (Hz)
MAX_SPEED = 1.0                # maksymalna prÄ™dkoÅ›Ä‡ wysyÅ‚ana do robota (-1..1)
SMOOTHING = 0.15              


def clamp(v, a=-1.0, b=1.0):
    return max(a, min(b, v))


def apply_deadzone(v, dz=DEADZONE):
    if abs(v) < dz:
        return 0.0
    sign = 1 if v >= 0 else -1
    scaled = (abs(v) - dz) / (1.0 - dz)
    return sign * scaled


def smooth_value(current, target, factor):
    """Proste wygÅ‚adzanie zmian (filtr 1. rzÄ™du)."""
    return current + (target - current) * (1.0 - factor)


def send_lr(ser, l, r):
    cmd = f"S LR {l:.3f} {r:.3f}\n"
    ser.write(cmd.encode("ascii"))


def send_stop(ser):
    ser.write(b"STOP\n")


def main():
    # Serial
    ser = serial.Serial(SERIAL_PORT, BAUDRATE, timeout=0.1)
    time.sleep(0.5)
    print(f"âœ… PoÅ‚Ä…czono z {SERIAL_PORT} ({BAUDRATE} bps)")

    # Pygame init
    pygame.init()
    pygame.joystick.init()

    if pygame.joystick.get_count() == 0:
        print("âŒ Brak podÅ‚Ä…czonych padÃ³w!")
        return

    joy = pygame.joystick.Joystick(0)
    joy.init()
    print(f"ðŸŽ® UÅ¼ywany pad: {joy.get_name()} ({joy.get_numaxes()} osi)")

    clock = pygame.time.Clock()

    # wartoÅ›ci bieÅ¼Ä…ce
    current_left = 0.0
    current_right = 0.0

    try:
        while True:
            pygame.event.pump()

            # Prawa galka
            # typowo:
            #   axis 2 = X prawej gaÅ‚ki (skrÄ™t)
            #   axis 3 = Y prawej gaÅ‚ki (przÃ³d/tyÅ‚)
            axis_turn = joy.get_axis(2) if joy.get_numaxes() > 2 else 0.0
            axis_forward = -joy.get_axis(3) if joy.get_numaxes() > 3 else 0.0

            f = apply_deadzone(axis_forward)
            t = apply_deadzone(axis_turn)

            # Mieszanie rÃ³Å¼nicowe
            target_left = clamp((f + t) * MAX_SPEED)
            target_right = clamp((f - t) * MAX_SPEED)

            # WygÅ‚adzanie (pÅ‚ynne przyspieszanie/hamowanie)
            current_left = smooth_value(current_left, target_left, SMOOTHING)
            current_right = smooth_value(current_right, target_right, SMOOTHING)

            send_lr(ser, current_left, current_right)

            # Debug (odkomentuj, jeÅ›li chcesz widzieÄ‡ wartoÅ›ci)
            # print(f"F:{f:+.2f} T:{t:+.2f} -> L:{current_left:+.2f} R:{current_right:+.2f}")

            clock.tick(SEND_HZ)

    except KeyboardInterrupt:
        print("\nðŸŸ¥ Zatrzymano przez uÅ¼ytkownika.")
        send_stop(ser)
    finally:
        send_stop(ser)
        joy.quit()
        pygame.joystick.quit()
        pygame.quit()
        ser.close()
        print("ðŸ”Œ PoÅ‚Ä…czenie zakoÅ„czone.")


if __name__ == "__main__":
    main()

